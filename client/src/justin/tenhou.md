下面把这份（被压缩过的）Tenhou 牌效计算器源码拆开讲一下它**在做什么、怎么做**。你给它一串 13/14 张牌，页面会给出“最优打牌与有效牌数”。核心就是：

1. 计算当前手牌的向听数（标准形/一般形两种口径）。
2. 枚举每一种“打这张 → 摸那张”的可能，把**能把向听减 1**的摸牌统计成“有效牌”，并按张数从多到少排序展示。

---

# 1. 数据表示（最重要的“读代码钥匙”）

* 34 张种类（0–33）：m1–m9、p1–p9、s1–s9、z1–z7。
* `ca()`/`E.l()`等函数会把 136 位“具体牌”（四张副本）折算成**34 维计数**数组 `e[0..33]`。
* `D()`/`g()`把**一个花色的 9 张计数**用 3bit × 9 的“打包整数”编码（每张 0–7 枚，因为搜索过程中临时会超 4），这样后面判胡/判听时位运算很快。

---

# 2. 判和了 / 听牌与“赢牌列表”

* 顶部的大函数 `u = (function(){ ... return function(a, b){ ... }})();`

  * 里边的 `d(c)` 是**标准形**（含七对/国士）的胡牌判定器（输入 34 维计数，返回能否和了）。
  * 其中：

    * `b(x)` 针对一个花色打包数判断能否分成**n 个顺子/刻子 + 雀头**；
    * `a(haiKind, packed)` 用来尝试把一个花色里“留作将”的位置枚举掉，再让剩余全用 `b()` 检；
    * 国士（十三幺）与七对在 `d()` 前半段用特判位掩码快速剪枝。
* `K(b)`：给定 34 维手牌计数，**枚举所有能和的牌**。做法是遍历 34 种牌 `+1` 后丢给 `u(…, 34)` 看是否成和，成就把那张牌记进列表。

---

# 3. 向听搜索（E 这一大坨）

`E` 是一个对象，内部是**深度搜索 + 强力剪枝**的向听计算器（只算一般形，七对/国士另算再取最小）。

关键成员：

* `E.l(b, 34)`：把输入的 34 维计数加载到内部数组 `e[0..33]`，各类计数器清零。
* `E.j()`：返回总枚数（13 或 14）。
* `E.o(total)`：**一般形的启发式下界**（估算的最优向听下界），用于剪枝。
* `E.m(total)`：把字牌等一些固定信息（对子/刻子/杠）预处理，设置剪枝位掩码。
* `E.s(x)`：根据“余下要组的面子个数”再做一次剪枝并调用 `E.u(0)` 进入 DFS。
* `E.u(h)`：**核心 DFS**。从第 `h` 种牌起，尝试

  * 取刻子（`--e[h]×3`）、
  * 取顺子（`--e[h],--e[h+1],--e[h+2]`）、
  * 取搭子（`--e[h],--e[h+1]` 或 `--e[h],--e[h+2]`）
    这些选择的组合来最小化“还差多少组/将”（即一般形向听数），并不断用 `this.v()` 里根据当前“面子数、搭子数、对子数”算出的**上界**更新 `E.g`（全局最优）。
  * 里面大量位运算变量（`t、v、l、q、k、p` 等）是在记录“哪些位置被当作将/搭了”、“红 5 相关”、“风牌状态”等，用于**剪枝**，避免指数爆炸。

两个对外小包装：

* `F(b, a)`：**只要向听**。`a` 表示是否一般形（`true` 时不含七对/国士）。流程：`E.l` → `E.j` → （14/13 枚判断）→（必要时先用 `E.o` 设初值）→ `E.m` → `E.s` → 结果 `E.g`。
* `G(b, a)`：**标准形/一般形两条线都算**，返回 `[标准形向听, 一般形向听]`。

---

# 4. 页面主逻辑（你看到的“打什么好”）

`fa()` 是整页的控制函数，做了这些事：

1. 解析输入字符串：

   * `"11067m66p..."` 通过 `aa()` → 136 位标识，再 `ca()` → 34 维计数 `f`。
   * 判断当前是 13 枚（听牌阶段）还是 14 枚（出牌阶段），以及 URL 决定“标准形(q\*) / 一般形(p\*)”。

2. 计算当前向听：

   * `e = G(f, 34)` 得到 `[标准, 一般]`，显示成“X 向听 / X 枚”等。

3. 枚举“打什么”与“有效牌”（核心就是**牌效**）：

   * 若 14 枚：对每个可打的种类 `k`：

     * 临时 `f[k]--`，再枚举所有可摸的牌 `p`（`f[p] < 4`）：

       * 试着 `f[p]++`，调用 `F(f, mode)` 得到**新向听**；能让向听 `== 当前向听 - 1` 就把 `p` 记作**有效牌**；
       * 统计“还剩几张”：`4 - f[p]`（减去手里已有的与用掉的一张），累加到这条“打 k”的候选项；
       * 回溯 `f[p]--`。
     * 回溯 `f[k]++`。
   * 若 13 枚（听牌场景）：没有“打”，只统计“直接能摸到把向听 -1 的牌”。

   这部分在 `fa()` 里对应的就是构造 `l[k]` 列表，然后

   ```js
   t[k] = { i: k, n: 有效牌总张数, c: [所有有效牌的索引] }
   ```

   最后 `t.sort((a,b)=>b.n-a.n)`，把**有效牌张数多的打牌**排在最前显示。

4. 生成 HTML：

   * `L()/da()` 负责把牌渲染成 `<img>` 或可点击 `<a>`，点击后会\*\*把该有效牌作为下次的“假设摸牌”\*\*继续算（你在网页里看到的“点击某有效牌后，下一个界面把它当成摸牌”的交互就是这样实现的）。

---

# 5. 你问的“如何得到最优解”

* “最优”在这个工具里是\*\*“打出后，使得 **能把向听 -1 的摸牌（有效牌）** 总张数最多\*\*”\*\*。
* 它不在这个页面里做役种评价、期待值（如打点/巡目/场况）等，只是**纯粹的牌效率**比较。

简化伪代码总结：

```js
// 输入：f[34] 手牌计数，mode = '标准形' 或 '一般形'
curr = G(f, 34)[modeIndex];   // 当前向听

candidates = []
for each tile k where f[k] > 0:           // 可打
  f[k]--
  effective = []
  totalLeft = 0
  for p in 0..33 where f[p] < 4:          // 可摸
    f[p]++
    if F(f, modeIsGeneral) == curr - 1:   // 能把向听降 1
        effective.push(p)
        totalLeft += 4 - f[p]             // 还剩几张
    f[p]--
  f[k]++
  if effective.length > 0:
    candidates.push({discard: k, tiles: effective, count: totalLeft})

sort candidates by count desc
display
```

---

# 6. 术语对照

* **一般形**：只算 4 面子 1 雀头（不含七对、国士）。
* **标准形**：一般形 + 七对 + 国士 → 取最小向听。
* **有效牌**：在当前操作（打/摸）后，能把向听减少 1 的所有牌（按“剩余枚数”计张）。

---

想自己调用的话，你只要把**34 维计数**灌进 `G()`/`F()`，再照上面的枚举逻辑跑一遍就能得到和网页一致的“打牌→有效牌数”排序结果了。
